import { Model } from '@nozbe/watermelondb';
import { Associations } from '@nozbe/watermelondb/Model';
import { date, readonly, text, relation, writer, field, json } from '@nozbe/watermelondb/decorators';

import { Plant } from './Plant';

export interface TaskCompletion {
  taskId: string;
  completedAt: Date;
  notes?: string;
  photos?: string[];
  nextScheduledDate?: Date;
  conditions?: {
    temperature?: number;
    humidity?: number;
    pH?: number;
  };
  supplies?: {
    used: string[];
    amounts: Record<string, number>;
  };
}

export interface EnvironmentalConditions {
  temperature?: number;
  humidity?: number;
  pH?: number;
  ec?: number;
  lightIntensity?: number;
}

export class PlantTask extends Model {
  static table = 'plant_tasks';
  static associations: Associations = {
    plants: { type: 'belongs_to' as const, key: 'plant_id' },
  };

  @text('task_id') taskId!: string;
  @text('plant_id') plantId!: string;
  @text('title') title!: string;
  @text('description') description?: string;
  @text('task_type') taskType!: string;
  @text('due_date') dueDate!: string;
  @text('status') status!: string;
  @text('notification_id') notificationId?: string;
  @text('user_id') userId!: string;
  
  // New task management fields
  @text('priority') priority?: 'low' | 'medium' | 'high' | 'critical';
  @field('estimated_duration') estimatedDuration?: number; // minutes
  @text('template_id') templateId?: string;
  @field('week_number') weekNumber?: number;
  @json('completion_data', (json) => json) completionData?: TaskCompletion;
  @field('auto_generated') autoGenerated?: boolean;
  @text('parent_task_id') parentTaskId?: string; // For recurring tasks
  @field('sequence_number') sequenceNumber?: number;
  @json('environmental_conditions', (json) => json) environmentalConditions?: EnvironmentalConditions;
  
  @readonly @date('created_at') createdAt!: Date;
  @readonly @date('updated_at') updatedAt!: Date;

  @relation('plants', 'plant_id') plant!: Plant;

  // Derived properties
  get isCompleted(): boolean {
    return this.status === 'completed';
  }

  get isOverdue(): boolean {
    if (this.isCompleted) return false;
    return new Date() > new Date(this.dueDate);
  }

  get isDueToday(): boolean {
    if (this.isCompleted) return false;
    const today = new Date();
    const dueDate = new Date(this.dueDate);
    
    return (
      today.getFullYear() === dueDate.getFullYear() &&
      today.getMonth() === dueDate.getMonth() &&
      today.getDate() === dueDate.getDate()
    );
  }

  get isDueSoon(): boolean {
    if (this.isCompleted) return false;
    const now = new Date();
    const timeDiff = new Date(this.dueDate).getTime() - now.getTime();
    const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
    
    return daysDiff <= 2 && daysDiff >= 0;
  }

  get daysUntilDue(): number {
    const now = new Date();
    const timeDiff = new Date(this.dueDate).getTime() - now.getTime();
    return Math.ceil(timeDiff / (1000 * 3600 * 24));
  }

  get priorityLevel(): 'low' | 'medium' | 'high' | 'critical' {
    if (this.priority) return this.priority;
    
    // Auto-calculate priority based on due date if not set
    if (this.isCompleted) return 'low';
    
    const daysUntil = this.daysUntilDue;
    
    if (daysUntil < 0) return 'critical'; // Overdue
    if (daysUntil === 0) return 'high'; // Due today
    if (daysUntil <= 2) return 'medium'; // Due soon
    return 'low'; // Due later
  }

  get formattedDueDate(): string {
    return new Date(this.dueDate).toLocaleDateString();
  }

  get estimatedDurationFormatted(): string {
    if (!this.estimatedDuration) return 'Unknown';
    
    const hours = Math.floor(this.estimatedDuration / 60);
    const minutes = this.estimatedDuration % 60;
    
    if (hours > 0) {
      return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    }
    return `${minutes}m`;
  }

  // Writer methods
  @writer async markAsCompleted(completionData?: Partial<TaskCompletion>) {
    await this.update((task) => {
      task.status = 'completed';
      task.notificationId = undefined; // Clear notification ID
      
      if (completionData) {
        task.completionData = {
          taskId: task.id,
          completedAt: new Date(),
          ...completionData,
        } as TaskCompletion;
      }
    });

    // If this is a recurring task, create the next one
    if (this.parentTaskId) {
      await this.createNextRecurringTask();
    }
  }

  @writer async markAsIncomplete() {
    await this.update((task) => {
      task.status = 'pending';
      task.completionData = undefined;
    });
  }

  @writer async reschedule(newDueDate: string) {
    await this.update((task) => {
      task.dueDate = newDueDate;
      task.status = 'pending';
    });
  }

  @writer async snooze(hours: number = 24) {
    const newDueDate = new Date(this.dueDate);
    newDueDate.setHours(newDueDate.getHours() + hours);
    await this.reschedule(newDueDate.toISOString());
  }

  @writer async updatePriority(newPriority: 'low' | 'medium' | 'high' | 'critical') {
    await this.update((task) => {
      task.priority = newPriority;
    });
  }

  @writer async updateEstimatedDuration(minutes: number) {
    await this.update((task) => {
      task.estimatedDuration = minutes;
    });
  }

  @writer async addEnvironmentalConditions(conditions: EnvironmentalConditions) {
    await this.update((task) => {
      task.environmentalConditions = {
        ...task.environmentalConditions,
        ...conditions,
      };
    });
  }

  private async createNextRecurringTask() {
    // Implementation for creating next recurring task
    // This would be used for tasks that repeat (like watering every 3 days)
    const database = this.database;
    
    // Calculate next due date based on task type and plant needs
    const nextDueDate = new Date(this.dueDate);
    
    // Default intervals by task type
    const intervals: Record<string, number> = {
      watering: 3, // days
      feeding: 7, // days
      inspection: 1, // days
      pruning: 14, // days
    };
    
    const interval = intervals[this.taskType] || 7;
    nextDueDate.setDate(nextDueDate.getDate() + interval);

    await database.write(async () => {
      await database.get<PlantTask>('plant_tasks').create((newTask) => {
        newTask.taskId = `${this.taskType}_${Date.now()}`;
        newTask.plantId = this.plantId;
        newTask.title = this.title;
        newTask.description = this.description;
        newTask.taskType = this.taskType;
        newTask.dueDate = nextDueDate.toISOString();
        newTask.status = 'pending';
        newTask.userId = this.userId;
        newTask.priority = this.priority;
        newTask.estimatedDuration = this.estimatedDuration;
        newTask.templateId = this.templateId;
        newTask.autoGenerated = true;
        newTask.parentTaskId = this.parentTaskId || this.id;
        newTask.sequenceNumber = (this.sequenceNumber || 0) + 1;
      });
    });
  }
}
