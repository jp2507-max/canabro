import { Model } from '@nozbe/watermelondb';
import type { TaskType } from '../types/taskTypes';
import { Associations } from '@nozbe/watermelondb/Model';
import { date, readonly, text, relation, writer, field, json } from '@nozbe/watermelondb/decorators';
import { log } from '../utils/logger';

import { Plant } from './Plant';
import { ScheduleTemplate, TemplateTaskData } from './ScheduleTemplate';
import { generateUuid } from '../utils/uuid';

export interface TaskCompletion {
  taskId: string;
  completedAt: Date;
  notes?: string;
  photos?: string[];
  nextScheduledDate?: Date;
  conditions?: {
    temperature?: number;
    humidity?: number;
    pH?: number;
  };
  supplies?: {
    used: string[];
    amounts: Record<string, number>;
  };
}

export interface EnvironmentalConditions {
  temperature?: number;
  humidity?: number;
  pH?: number;
  ec?: number;
  lightIntensity?: number;
}

export class PlantTask extends Model {
  static table = 'plant_tasks';
  static associations: Associations = {
    plants: { type: 'belongs_to' as const, key: 'plant_id' },
  };

  @text('task_id') taskId!: string;
  @text('plant_id') plantId!: string;
  @text('title') title!: string;
  @text('description') description?: string;
  @text('task_type') taskType!: TaskType;
  @text('due_date') dueDate!: string;
  @text('status') status!: string;
  @text('notification_id') notificationId?: string;
  @text('user_id') userId!: string;
  
  // New task management fields
  @text('priority') priority?: 'low' | 'medium' | 'high' | 'critical';
  @field('estimated_duration') estimatedDuration?: number; // minutes
  @text('template_id') templateId?: string;
  @field('week_number') weekNumber?: number;
  @json('completion_data', (json) => json) completionData?: TaskCompletion;
  @field('auto_generated') autoGenerated?: boolean;
  @text('parent_task_id') parentTaskId?: string; // For recurring tasks
  @field('sequence_number') sequenceNumber?: number;
  @json('environmental_conditions', (json) => json) environmentalConditions?: EnvironmentalConditions;
  @text('escalation_start_time') escalationStartTime?: string; // ISO string for escalation tracking
  
  @readonly @date('created_at') createdAt!: Date;
  @readonly @date('updated_at') updatedAt!: Date;

  @relation('plants', 'plant_id') plant!: Plant;

  // Derived properties
  get isCompleted(): boolean {
    return this.status === 'completed';
  }

  get isOverdue(): boolean {
    if (this.isCompleted) return false;
    return new Date() > new Date(this.dueDate);
  }

  get isDueToday(): boolean {
    if (this.isCompleted) return false;
    const today = new Date();
    const dueDate = new Date(this.dueDate);
    
    return (
      today.getFullYear() === dueDate.getFullYear() &&
      today.getMonth() === dueDate.getMonth() &&
      today.getDate() === dueDate.getDate()
    );
  }

  get isDueSoon(): boolean {
    if (this.isCompleted) return false;
    const now = new Date();
    const timeDiff = new Date(this.dueDate).getTime() - now.getTime();
    const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
    
    return daysDiff <= 2 && daysDiff >= 0;
  }

  get daysUntilDue(): number {
    const now = new Date();
    const timeDiff = new Date(this.dueDate).getTime() - now.getTime();
    return Math.ceil(timeDiff / (1000 * 3600 * 24));
  }

  get priorityLevel(): 'low' | 'medium' | 'high' | 'critical' {
    if (this.priority) return this.priority;
    
    // Auto-calculate priority based on due date if not set
    if (this.isCompleted) return 'low';
    
    const daysUntil = this.daysUntilDue;
    
    if (daysUntil < 0) return 'critical'; // Overdue
    if (daysUntil === 0) return 'high'; // Due today
    if (daysUntil <= 2) return 'medium'; // Due soon
    return 'low'; // Due later
  }

  get formattedDueDate(): string {
    return new Date(this.dueDate).toLocaleDateString();
  }

  get estimatedDurationFormatted(): string {
    if (!this.estimatedDuration) return 'Unknown';
    
    const hours = Math.floor(this.estimatedDuration / 60);
    const minutes = this.estimatedDuration % 60;
    
    if (hours > 0) {
      return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    }
    return `${minutes}m`;
  }

  // Writer methods
  @writer async markAsCompleted(completionData?: Partial<TaskCompletion>) {
    // First, update the task status and completion data synchronously
    await this.update((task) => {
      task.status = 'completed';
      task.notificationId = undefined; // Clear notification ID
      
      if (completionData) {
        task.completionData = {
          taskId: task.id,
          completedAt: new Date(),
          ...completionData,
        } as TaskCompletion;
      }
    });

    // If this is a recurring task (either initial or child), create the next one
    // The initial task has no parentTaskId, so we check if it is part of a recurring series by other means
    // For now, assume that if sequenceNumber is defined or templateId is set, it's a recurring task
    if (this.templateId || this.parentTaskId) {
      await this.createNextRecurringTask();
    }
  }

  @writer async markAsIncomplete() {
    await this.update((task) => {
      task.status = 'pending';
      task.completionData = undefined;
    });
  }

  @writer async reschedule(newDueDate: string) {
    await this.update((task) => {
      task.dueDate = newDueDate;
      task.status = 'pending';
    });
  }

  @writer async snooze(hours: number = 24) {
    const newDueDate = new Date(this.dueDate);
    newDueDate.setHours(newDueDate.getHours() + hours);
    await this.reschedule(newDueDate.toISOString());
  }

  @writer async updatePriority(newPriority: 'low' | 'medium' | 'high' | 'critical') {
    await this.update((task) => {
      task.priority = newPriority;
    });
  }

  @writer async updateEstimatedDuration(minutes: number) {
    await this.update((task) => {
      task.estimatedDuration = minutes;
    });
  }

  @writer async addEnvironmentalConditions(conditions: EnvironmentalConditions) {
    await this.update((task) => {
      task.environmentalConditions = {
        ...task.environmentalConditions,
        ...conditions,
      };
    });
  }

  @writer async setEscalationStartTime(timestamp?: Date) {
    await this.update((task) => {
      task.escalationStartTime = timestamp ? timestamp.toISOString() : new Date().toISOString();
    });
  }

  @writer
  private async createNextRecurringTask() {
    try {
      // Implementation for creating next recurring task
      // This would be used for tasks that repeat (like watering every 3 days)
      const database = this.database;
      
      // Calculate next due date based on task type and configurable intervals
      const nextDueDate = new Date(this.dueDate);
      
      // Get interval from template or plant settings, fallback to defaults
      const interval = await this.getRecurringInterval();
      nextDueDate.setDate(nextDueDate.getDate() + interval);
    
      // Create the next task within the existing transaction with error handling
      await database.get<PlantTask>('plant_tasks').create((newTask) => {
        // Use robust UUID generation instead of timestamp-based ID
        newTask.taskId = generateUuid();
        newTask.plantId = this.plantId;
        newTask.title = this.title;
        newTask.description = this.description;
        newTask.taskType = this.taskType;
        newTask.dueDate = nextDueDate.toISOString();
        newTask.status = 'pending';
        newTask.userId = this.userId;
        newTask.priority = this.priority;
        newTask.estimatedDuration = this.estimatedDuration;
        newTask.templateId = this.templateId;
        newTask.autoGenerated = true;
        newTask.parentTaskId = this.parentTaskId || this.id;
        newTask.sequenceNumber = (this.sequenceNumber || 0) + 1;
      });
      
      log.info(`[PlantTask] Successfully created next recurring task for ${this.taskType} with ${interval} day interval`);
    } catch (error) {
      log.error(`[PlantTask] Failed to create next recurring task for ${this.taskType}:`, error);
      // Don't throw the error to prevent parent transaction from failing
      // The current task completion should still succeed even if next task creation fails
    }
  }

  /**
   * Gets the recurring interval for this task type from various sources
   * Priority: Template data > Plant-specific settings > Default intervals
   */
  private async getRecurringInterval(): Promise<number> {
    try {
      // First, try to get interval from template if available
      if (this.templateId) {
        const template = await this.database.get<ScheduleTemplate>('schedule_templates').find(this.templateId);
        const taskData = template?.templateData?.find((task: TemplateTaskData) => task.taskType === this.taskType);
        if (taskData) {
          // Calculate interval based on template task frequency
          // For now, use a simple weekly interval, but this could be enhanced
          // to support more complex scheduling patterns from template data
          return 7; // Default weekly interval from template
        }
      }

      // Second, try to get plant-specific intervals if plant has custom settings
      const plant = await this.database.get<Plant>('plants').find(this.plantId).catch(() => null);
      
      // Check for plant-specific watering/feeding intervals using optional chaining
      if (this.taskType === 'watering' && plant?.nextWateringDays) {
        return plant.nextWateringDays;
      }
      if (this.taskType === 'feeding' && plant?.nextNutrientDays) {
        return plant.nextNutrientDays;
      }
    } catch (error) {
      log.error(`[PlantTask] Error retrieving custom intervals for ${this.taskType}`, { error });
      // Fall through to default intervals
    }

    // Fallback to default intervals by task type
    const defaultIntervals: Record<string, number> = {
      watering: 3, // days
      feeding: 7, // days
      inspection: 1, // days
      pruning: 14, // days
      training: 7, // days
      defoliation: 14, // days
      flushing: 21, // days
      harvest: 70, // days (full cycle)
    };
    
    return defaultIntervals[this.taskType] || 7; // Default to weekly if task type not found
  }
}
