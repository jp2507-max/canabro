import { Model } from '@nozbe/watermelondb';
import { Associations } from '@nozbe/watermelondb/Model';
import { date, readonly, text, relation, writer, field } from '@nozbe/watermelondb/decorators';

import { Plant } from './Plant';
import { log } from '@/lib/utils/logger';

export interface TaskCompletion {
  taskId: string;
  completedAt: Date;
  notes?: string;
  photos?: string[];
  nextScheduledDate?: Date;
  conditions?: {
    temperature?: number;
    humidity?: number;
    pH?: number;
  };
  supplies?: {
    used: string[];
    amounts: Record<string, number>;
  };
}

export interface EnvironmentalConditions {
  temperature?: number;
  humidity?: number;
  pH?: number;
  lightHours?: number;
  co2Level?: number;
}

export class PlantTask extends Model {
  static table = 'plant_tasks';
  static associations: Associations = {
    plants: { type: 'belongs_to' as const, key: 'plant_id' },
  };

  @text('task_id') taskId!: string;
  @text('plant_id') plantId!: string;
  @text('title') title!: string;
  @text('description') description?: string;
  @text('task_type') taskType!: string;
  @text('due_date') dueDate!: string;
  @text('status') status!: string;
  @text('notification_id') notificationId?: string;
  @text('user_id') userId!: string;
  
  // Calendar-specific fields
  @text('template_id') templateId?: string;
  @field('week_number') weekNumber?: number;
  @field('estimated_duration') estimatedDuration?: number; // minutes
  @field('completion_data') completionData?: string; // JSON string
  @field('auto_generated') autoGenerated?: boolean;
  @text('parent_task_id') parentTaskId?: string; // For recurring tasks
  @field('sequence_number') sequenceNumber?: number;
  @field('environmental_conditions') environmentalConditions?: string; // JSON string
  @text('priority') priority?: string; // 'low', 'medium', 'high', 'critical'
  @date('scheduled_date') scheduledDate?: Date;
  @field('is_recurring') isRecurring?: boolean;
  @text('recurrence_pattern') recurrencePattern?: string;
  @date('last_synced_at') lastSyncedAt?: Date;
  @field('is_deleted') isDeleted?: boolean;
  
  @readonly @date('created_at') createdAt!: Date;
  @readonly @date('updated_at') updatedAt!: Date;

  @relation('plants', 'plant_id') plant!: Plant;

  @writer async markAsCompleted(completionData?: TaskCompletion) {
    await this.update((task) => {
      task.status = 'completed';
      task.notificationId = undefined; // Clear notification ID
      if (completionData) {
        task.completionData = JSON.stringify(completionData);
      }
    });
  }

  @writer async updatePriority(priority: string) {
    await this.update((task) => {
      task.priority = priority;
    });
  }

  @writer async reschedule(newDate: Date) {
    await this.update((task) => {
      task.scheduledDate = newDate;
      task.dueDate = newDate.toISOString();
    });
  }

  @writer async updateEnvironmentalConditions(conditions: EnvironmentalConditions) {
    await this.update((task) => {
      const currentConditions = this.getEnvironmentalConditions();
      task.environmentalConditions = JSON.stringify({ ...currentConditions, ...conditions });
    });
  }

  // Helper methods for JSON fields
  getCompletionData(): TaskCompletion | null {
    if (!this.completionData) return null;
    
    try {
      return JSON.parse(this.completionData);
    } catch (error) {
      log.error('Failed to parse completion data:', error);
      return null;
    }
  }

  getEnvironmentalConditions(): EnvironmentalConditions {
    if (!this.environmentalConditions) return {};
    
    try {
      return JSON.parse(this.environmentalConditions);
    } catch (error) {
      log.error('Failed to parse environmental conditions:', error);
      return {};
    }
  }

  @writer async markAsDeleted() {
    await this.update((task) => {
      task.isDeleted = true;
    });
  }

  @writer async setRecurring(pattern: string) {
    await this.update((task) => {
      task.isRecurring = true;
      task.recurrencePattern = pattern;
    });
  }

  // Helper methods
  get isActive(): boolean {
    return !this.isDeleted;
  }

  get isAutoGenerated(): boolean {
    return this.autoGenerated ?? false;
  }

  get isOverdue(): boolean {
    if (this.status === 'completed') return false;
    const dueDate = new Date(this.dueDate);
    return dueDate < new Date();
  }

  get isPending(): boolean {
    return this.status === 'pending';
  }

  get isCompleted(): boolean {
    return this.status === 'completed';
  }

  get hasHighPriority(): boolean {
    return this.priority === 'high' || this.priority === 'critical';
  }

  get estimatedDurationHours(): number {
    return this.estimatedDuration ? this.estimatedDuration / 60 : 0;
  }

  getDaysUntilDue(): number {
    const dueDate = new Date(this.dueDate);
    const today = new Date();
    const diffTime = dueDate.getTime() - today.getTime();
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  isScheduledForDate(date: Date): boolean {
    if (!this.scheduledDate) return false;
    const taskDate = new Date(this.scheduledDate);
    return (
      taskDate.getFullYear() === date.getFullYear() &&
      taskDate.getMonth() === date.getMonth() &&
      taskDate.getDate() === date.getDate()
    );
  }
}
