import { Plant } from '../models/Plant';
import { PlantTask } from '../models/PlantTask';
import { HarvestPredictionService, HarvestPrediction } from './HarvestPredictionService';
import { log } from '../utils/logger';
import { addDays, subDays, format } from '../utils/date';
import { generateUuid } from '../utils/uuid';
import { getDatabase } from '../database/database';
import { Q } from '@nozbe/watermelondb';

export interface HarvestPreparationTask {
  taskType: 'flushing' | 'defoliation' | 'inspection' | 'harvest';
  title: string;
  description: string;
  daysBeforeHarvest: number;
  priority: 'low' | 'medium' | 'high' | 'critical';
  estimatedDuration: number; // minutes
  supplies?: string[];
}

export interface HarvestPreparationPlan {
  plantId: string;
  harvestPrediction: HarvestPrediction;
  preparationTasks: HarvestPreparationTask[];
  totalPreparationDays: number;
  isAutoGenerated: boolean;
}

export class HarvestPreparationAutomator {
  private static readonly PREPARATION_TASKS: HarvestPreparationTask[] = [
    {
      taskType: 'flushing',
      title: 'Start Final Flush',
      description: 'Begin flushing with plain water to remove nutrients and improve taste',
      daysBeforeHarvest: 14,
      priority: 'high',
      estimatedDuration: 30,
      supplies: ['pH meter', 'Plain water', 'TDS meter'],
    },
    {
      taskType: 'defoliation',
      title: 'Final Defoliation',
      description: 'Remove large fan leaves to improve airflow and light penetration',
      daysBeforeHarvest: 10,
      priority: 'medium',
      estimatedDuration: 45,
      supplies: ['Pruning shears', 'Gloves'],
    },
    {
      taskType: 'inspection',
      title: 'Prepare Drying Environment',
      description: 'Set up drying room with proper temperature (60-70Â°F) and humidity (45-55%)',
      daysBeforeHarvest: 7,
      priority: 'high',
      estimatedDuration: 60,
      supplies: ['Hygrometer', 'Dehumidifier', 'Fan', 'Drying racks'],
    },
    {
      taskType: 'inspection',
      title: 'Prepare Harvest Equipment',
      description: 'Clean and organize all harvest tools and containers',
      daysBeforeHarvest: 3,
      priority: 'medium',
      estimatedDuration: 30,
      supplies: ['Trimming scissors', 'Gloves', 'Collection containers', 'Isopropyl alcohol'],
    },
    {
      taskType: 'harvest',
      title: 'Final Harvest Check',
      description: 'Final inspection of trichomes and pistils before harvest',
      daysBeforeHarvest: 1,
      priority: 'critical',
      estimatedDuration: 15,
      supplies: ['Magnifying glass', 'Jewelers loupe'],
    },
  ];

  /**
   * Creates a comprehensive harvest preparation plan for a plant
   */
  static async createHarvestPreparationPlan(plant: Plant): Promise<HarvestPreparationPlan> {
    try {
      log.info(`[HarvestPreparationAutomator] Creating harvest preparation plan for plant ${plant.id}`);

      // Get harvest prediction
      const harvestPrediction = await HarvestPredictionService.predictHarvestDate(plant);
      
      // Filter and customize tasks based on plant characteristics
      const preparationTasks = this.customizePreparationTasks(plant, harvestPrediction);
      
      const plan: HarvestPreparationPlan = {
        plantId: plant.id,
        harvestPrediction,
        preparationTasks,
        totalPreparationDays: Math.max(...preparationTasks.map(t => t.daysBeforeHarvest)),
        isAutoGenerated: true,
      };
      
      log.info(`[HarvestPreparationAutomator] Created preparation plan with ${preparationTasks.length} tasks`);
      
      return plan;
    } catch (error) {
      log.error(`[HarvestPreparationAutomator] Error creating harvest preparation plan:`, error);
      throw error;
    }
  }

  /**
   * Automatically schedules harvest preparation tasks based on predicted harvest date
   */
  static async scheduleHarvestPreparationTasks(plant: Plant): Promise<PlantTask[]> {
    try {
      log.info(`[HarvestPreparationAutomator] Scheduling harvest preparation tasks for plant ${plant.id}`);

      const plan = await this.createHarvestPreparationPlan(plant);
      const database = getDatabase();
      const createdTasks: PlantTask[] = [];

      await database.write(async () => {
        for (const prepTask of plan.preparationTasks) {
          // Calculate task due date
          const dueDate = subDays(plan.harvestPrediction.predictedHarvestDate, prepTask.daysBeforeHarvest);
          
          // Skip tasks that are already past due by more than a week
          if (dueDate < subDays(new Date(), 7)) {
            log.info(`[HarvestPreparationAutomator] Skipping past due task: ${prepTask.title}`);
            continue;
          }

          // Check if similar task already exists
          const existingTasks = await database
            .get('plant_tasks')
            .query(
              Q.where('plant_id', plant.id),
              Q.where('task_type', prepTask.taskType),
              Q.where('status', Q.notEq('completed')),
              Q.where('due_date', Q.gte(subDays(dueDate, 2).toISOString())),
              Q.where('due_date', Q.lte(addDays(dueDate, 2).toISOString()))
            )
            .fetch();

          if (existingTasks.length > 0) {
            log.info(`[HarvestPreparationAutomator] Similar task already exists: ${prepTask.title}`);
            continue;
          }

          // Create the task
          const task = await database.get('plant_tasks').create((newTask: any) => {
            newTask.taskId = generateUuid();
            newTask.plantId = plant.id;
            newTask.title = prepTask.title;
            newTask.description = prepTask.description;
            newTask.taskType = prepTask.taskType;
            newTask.dueDate = dueDate.toISOString();
            newTask.status = 'pending';
            newTask.userId = (plant as any).userId;
            newTask.priority = prepTask.priority;
            newTask.estimatedDuration = prepTask.estimatedDuration;
            newTask.autoGenerated = true;
            newTask.templateId = 'harvest_preparation';
          });

          createdTasks.push(task as PlantTask);
          log.info(`[HarvestPreparationAutomator] Created task: ${prepTask.title} due ${format(dueDate, 'yyyy-MM-dd')}`);
        }
      });

      log.info(`[HarvestPreparationAutomator] Successfully created ${createdTasks.length} harvest preparation tasks`);
      return createdTasks;
    } catch (error) {
      log.error(`[HarvestPreparationAutomator] Error scheduling harvest preparation tasks:`, error);
      throw error;
    }
  }

  /**
   * Updates harvest preparation tasks when harvest prediction changes
   */
  static async updateHarvestPreparationTasks(plant: Plant): Promise<void> {
    try {
      log.info(`[HarvestPreparationAutomator] Updating harvest preparation tasks for plant ${plant.id}`);

      const database = getDatabase();
      
      // Get existing harvest preparation tasks
      const existingTasks = await database
        .get('plant_tasks')
        .query(
          Q.where('plant_id', plant.id),
          Q.where('template_id', 'harvest_preparation'),
          Q.where('status', Q.notEq('completed'))
        )
        .fetch();

      if (existingTasks.length === 0) {
        // No existing tasks, create new ones
        await this.scheduleHarvestPreparationTasks(plant);
        return;
      }

      // Get new harvest prediction
      const newPrediction = await HarvestPredictionService.predictHarvestDate(plant);
      
      await database.write(async () => {
        for (const task of existingTasks) {
          // Find corresponding preparation task template
          const prepTask = this.PREPARATION_TASKS.find(pt => pt.taskType === (task as any).taskType);
          if (!prepTask) continue;

          // Calculate new due date
          const newDueDate = subDays(newPrediction.predictedHarvestDate, prepTask.daysBeforeHarvest);
          
          // Update task if due date changed significantly (more than 1 day difference)
          const currentDueDate = new Date((task as any).dueDate);
          const daysDifference = Math.abs((newDueDate.getTime() - currentDueDate.getTime()) / (1000 * 60 * 60 * 24));
          
          if (daysDifference > 1) {
            await task.update((t: any) => {
              t.dueDate = newDueDate.toISOString();
            });
            
            log.info(`[HarvestPreparationAutomator] Updated task ${(task as any).title} due date to ${format(newDueDate, 'yyyy-MM-dd')}`);
          }
        }
      });

      log.info(`[HarvestPreparationAutomator] Updated harvest preparation tasks for plant ${plant.id}`);
    } catch (error) {
      log.error(`[HarvestPreparationAutomator] Error updating harvest preparation tasks:`, error);
    }
  }

  /**
   * Checks if harvest preparation should be triggered based on plant readiness
   */
  static async shouldTriggerHarvestPreparation(plant: Plant): Promise<boolean> {
    try {
      const prediction = await HarvestPredictionService.predictHarvestDate(plant);
      
      // Trigger preparation if:
      // 1. Plant is in flowering stage
      // 2. Harvest is predicted within 21 days
      // 3. Confidence is medium or high
      const isFlowering = ['flowering', 'late-flowering'].includes(plant.growthStage);
      const isWithinPreparationWindow = prediction.daysRemaining <= 21;
      const hasReasonableConfidence = ['medium', 'high'].includes(prediction.confidence);
      
      return isFlowering && isWithinPreparationWindow && hasReasonableConfidence;
    } catch (error) {
      log.error(`[HarvestPreparationAutomator] Error checking harvest preparation trigger:`, error);
      return false;
    }
  }

  /**
   * Automatically triggers harvest preparation for plants that are ready
   */
  static async autoTriggerHarvestPreparation(plants: Plant[]): Promise<void> {
    try {
      log.info(`[HarvestPreparationAutomator] Checking ${plants.length} plants for harvest preparation trigger`);

      for (const plant of plants) {
        const shouldTrigger = await this.shouldTriggerHarvestPreparation(plant);
        
        if (shouldTrigger) {
          log.info(`[HarvestPreparationAutomator] Triggering harvest preparation for plant ${plant.id}`);
          await this.scheduleHarvestPreparationTasks(plant);
        }
      }
    } catch (error) {
      log.error(`[HarvestPreparationAutomator] Error in auto-trigger harvest preparation:`, error);
    }
  }

  private static customizePreparationTasks(
    plant: Plant,
    prediction: HarvestPrediction
  ): HarvestPreparationTask[] {
    let tasks = [...this.PREPARATION_TASKS];
    
    // Customize based on plant characteristics
    if (plant.isAutoFlower) {
      // Auto-flowers may need shorter flush period
      const flushTask = tasks.find(t => t.taskType === 'flushing');
      if (flushTask) {
        flushTask.daysBeforeHarvest = 10; // Shorter flush for autos
        flushTask.description = 'Begin flushing with plain water (shorter period for auto-flower)';
      }
    }
    
    // Adjust based on prediction confidence
    if (prediction.confidence === 'low') {
      // Add extra monitoring tasks for low confidence predictions
      tasks.push({
        taskType: 'inspection',
        title: 'Daily Harvest Readiness Check',
        description: 'Check trichomes and pistils daily due to uncertain harvest timing',
        daysBeforeHarvest: 5,
        priority: 'high',
        estimatedDuration: 10,
        supplies: ['Magnifying glass'],
      });
    }
    
    // Customize based on growth medium
    if (plant.growMedium === 'hydroponic') {
      const flushTask = tasks.find(t => t.taskType === 'flushing');
      if (flushTask) {
        flushTask.description = 'Begin flushing hydroponic system with plain water and check EC levels';
        flushTask.supplies = ['pH meter', 'EC meter', 'Plain water'];
      }
    }
    
    return tasks.sort((a, b) => b.daysBeforeHarvest - a.daysBeforeHarvest);
  }
}