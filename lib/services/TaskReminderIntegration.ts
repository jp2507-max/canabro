/**
 * Task Reminder Integration Service
 * 
 * Integrates TaskReminderEngine with existing task management services
 * and provides seamless notification management for the task system.
 * 
 * This service acts as a bridge between:
 * - TaskAutomationService (task creation and scheduling)
 * - TaskSchedulingAdapter (task lifecycle management)
 * - TaskReminderEngine (notification management)
 * - PlantTask model (data persistence)
 */

import { Q } from '@nozbe/watermelondb';

import { database } from '@/lib/models';
import { PlantTask } from '@/lib/models/PlantTask';
import { Plant } from '@/lib/models/Plant';
import { taskReminderEngine, TaskNotificationConfig } from './TaskReminderEngine';
import { TaskAutomationService } from './TaskAutomationService';
import { TaskSchedulingAdapter } from './TaskSchedulingAdapter';
import { Logger } from '@/lib/utils/production-utils';
import { TaskType } from '@/lib/types/taskTypes';
import { GrowthStage } from '@/lib/types/plant';

export class TaskReminderIntegration {
  private static instance: TaskReminderIntegration;

  public static getInstance(): TaskReminderIntegration {
    if (!TaskReminderIntegration.instance) {
      TaskReminderIntegration.instance = new TaskReminderIntegration();
    }
    return TaskReminderIntegration.instance;
  }

  /**
   * Initialize task reminder system for a plant
   * Called when a plant is created or when growth stage changes
   */
  async initializeTaskReminders(plant: Plant, growthStage?: GrowthStage): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Initializing task reminders for plant', { 
        plantId: plant.id, 
        plantName: plant.name,
        growthStage: growthStage || plant.growthStage 
      });

      // Generate tasks for the plant's current growth stage
      const tasks = await TaskAutomationService.scheduleForGrowthStage(
        plant, 
        (growthStage || plant.growthStage) as GrowthStage
      );

      if (tasks.length > 0) {
        // Schedule notifications for all generated tasks
        await this.scheduleNotificationsForTasks(tasks);
        
        Logger.info('[TaskReminderIntegration] Initialized reminders for plant', { 
          plantId: plant.id, 
          taskCount: tasks.length 
        });
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error initializing task reminders', { 
        plantId: plant.id, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle growth stage transition
   * Updates task schedules and notifications when plant growth stage changes
   */
  async handleGrowthStageTransition(
    plant: Plant, 
    oldStage: GrowthStage, 
    newStage: GrowthStage
  ): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling growth stage transition', { 
        plantId: plant.id, 
        oldStage, 
        newStage 
      });

      // Cancel notifications for old stage tasks that are no longer relevant
      await this.cancelNotificationsForGrowthStage(plant.id, oldStage);

      // Update existing tasks for new growth stage
      await TaskSchedulingAdapter.updateTasksForGrowthStageChange(plant, oldStage, newStage);

      // Generate new tasks for the new growth stage
      const newTasks = await TaskAutomationService.scheduleForGrowthStage(plant, newStage);

      // Schedule notifications for new tasks
      if (newTasks.length > 0) {
        await this.scheduleNotificationsForTasks(newTasks);
      }

      Logger.info('[TaskReminderIntegration] Completed growth stage transition', { 
        plantId: plant.id, 
        newTaskCount: newTasks.length 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling growth stage transition', { 
        plantId: plant.id, 
        oldStage, 
        newStage, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle task completion
   * Updates notifications and schedules next recurring task if applicable
   */
  async handleTaskCompletion(task: PlantTask): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task completion', { 
        taskId: task.id, 
        taskType: task.taskType 
      });

      // Cancel notifications for completed task
      await taskReminderEngine.cancelTaskNotifications(task.id);

      // If this is a recurring task, the PlantTask model will automatically
      // create the next occurrence. We need to schedule notifications for it.
      if (task.autoGenerated && (task.templateId || task.parentTaskId)) {
        // Wait a moment for the next task to be created
        setTimeout(async () => {
          await this.scheduleNotificationsForNextRecurringTask(task);
        }, 1000);
      }

      Logger.info('[TaskReminderIntegration] Completed task completion handling', { 
        taskId: task.id 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task completion', { 
        taskId: task.id, 
        error 
      });
      // Don't throw here as task completion should still succeed
    }
  }

  /**
   * Handle task rescheduling
   * Updates notification timing when task due date changes
   */
  async handleTaskReschedule(task: PlantTask, newDueDate: Date): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task reschedule', { 
        taskId: task.id, 
        oldDueDate: task.dueDate, 
        newDueDate 
      });

      // Reschedule the notification
      await taskReminderEngine.rescheduleTaskNotification(task.id, newDueDate);

      Logger.info('[TaskReminderIntegration] Completed task reschedule', { taskId: task.id });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task reschedule', { 
        taskId: task.id, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle task deletion
   * Cancels all notifications for deleted task
   */
  async handleTaskDeletion(taskId: string): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task deletion', { taskId });

      // Cancel all notifications for the task
      await taskReminderEngine.cancelTaskNotifications(taskId);

      Logger.info('[TaskReminderIntegration] Completed task deletion handling', { taskId });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task deletion', { 
        taskId, 
        error 
      });
      // Don't throw here as task deletion should still succeed
    }
  }

  /**
   * Bulk operations for task management
   */
  async handleBulkTaskCompletion(taskIds: string[]): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling bulk task completion', { 
        taskCount: taskIds.length 
      });

      // Cancel notifications for all completed tasks
      const cancelPromises = taskIds.map(taskId => 
        taskReminderEngine.cancelTaskNotifications(taskId)
      );

      await Promise.allSettled(cancelPromises);

      // Handle recurring task scheduling for each completed task
      for (const taskId of taskIds) {
        try {
          const task = await database.get<PlantTask>('plant_tasks').find(taskId);
          if (task.autoGenerated && (task.templateId || task.parentTaskId)) {
            setTimeout(async () => {
              await this.scheduleNotificationsForNextRecurringTask(task);
            }, 1000);
          }
        } catch (taskError) {
          Logger.warn('[TaskReminderIntegration] Could not handle recurring task for completed task', { 
            taskId, 
            error: taskError 
          });
        }
      }

      Logger.info('[TaskReminderIntegration] Completed bulk task completion handling');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling bulk task completion', { error });
      throw error;
    }
  }

  async handleBulkTaskReschedule(taskIds: string[], newDueDate: Date): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling bulk task reschedule', { 
        taskCount: taskIds.length, 
        newDueDate 
      });

      // Reschedule notifications for all tasks
      const reschedulePromises = taskIds.map(taskId => 
        taskReminderEngine.rescheduleTaskNotification(taskId, newDueDate)
      );

      await Promise.allSettled(reschedulePromises);

      Logger.info('[TaskReminderIntegration] Completed bulk task reschedule handling');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling bulk task reschedule', { error });
      throw error;
    }
  }

  /**
   * Environmental condition updates
   * Adjusts task schedules and notifications based on environmental changes
   */
  async handleEnvironmentalUpdate(
    plantId: string, 
    conditions: {
      temperature?: number;
      humidity?: number;
      pH?: number;
    }
  ): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling environmental update', { 
        plantId, 
        conditions 
      });

      // Adjust task schedules based on environmental conditions
      await TaskAutomationService.adjustScheduleForConditions(plantId, conditions);

      // Get updated tasks and reschedule notifications
      const updatedTasks = await this.getActiveTasks(plantId);
      await this.scheduleNotificationsForTasks(updatedTasks);

      Logger.info('[TaskReminderIntegration] Completed environmental update handling', { 
        plantId, 
        updatedTaskCount: updatedTasks.length 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling environmental update', { 
        plantId, 
        error 
      });
      throw error;
    }
  }

  /**
   * Process overdue tasks across all plants
   * Should be called periodically (e.g., every 5 minutes)
   */
  async processOverdueTasks(): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Processing overdue tasks');

      await taskReminderEngine.processOverdueTasks();

      Logger.info('[TaskReminderIntegration] Completed overdue task processing');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error processing overdue tasks', { error });
      throw error;
    }
  }

  /**
   * Private helper methods
   */

  private async scheduleNotificationsForTasks(tasks: PlantTask[]): Promise<void> {
    try {
      const configs: TaskNotificationConfig[] = [];

      for (const task of tasks) {
        try {
          const plant = await database.get<Plant>('plants').find(task.plantId);
          
          const config: TaskNotificationConfig = {
            taskId: task.id,
            plantId: task.plantId,
            plantName: plant.name,
            taskType: task.taskType as TaskType,
            taskTitle: task.title,
            dueDate: new Date(task.dueDate),
            priority: task.priority || 'medium',
            estimatedDuration: task.estimatedDuration,
            isRecurring: task.autoGenerated,
          };

          configs.push(config);
        } catch (plantError) {
          Logger.warn('[TaskReminderIntegration] Could not fetch plant for task notification', { 
            taskId: task.id, 
            error: plantError 
          });
        }
      }

      if (configs.length > 0) {
        await taskReminderEngine.scheduleTaskNotifications(configs);
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error scheduling notifications for tasks', { error });
      throw error;
    }
  }

  private async cancelNotificationsForGrowthStage(
    plantId: string, 
    growthStage: GrowthStage
  ): Promise<void> {
    try {

      // TODO: Add 'growth_stage' field to PlantTask model to enable filtering by growth stage here.
      // Tracking requirement: This is needed for precise notification cancellation when growth stage changes.
      // For now, we'll cancel all pending notifications and reschedule.
      const tasks = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', plantId),
          Q.where('status', 'pending')
        )
        .fetch();

      const cancelPromises = tasks.map(task => 
        taskReminderEngine.cancelTaskNotifications(task.id)
      );

      await Promise.allSettled(cancelPromises);
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error cancelling notifications for growth stage', { 
        plantId, 
        growthStage, 
        error 
      });
    }
  }

  private async scheduleNotificationsForNextRecurringTask(completedTask: PlantTask): Promise<void> {
    try {
      // Find the next task in the recurring series
      const nextTask = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', completedTask.plantId),
          Q.where('task_type', completedTask.taskType),
          Q.where('status', 'pending'),
          Q.where('parent_task_id', completedTask.parentTaskId || completedTask.id),
          Q.where('sequence_number', Q.gt(completedTask.sequenceNumber || 0)),
          Q.sortBy('sequence_number', Q.asc),
          Q.take(1)
        )
        .fetch();

      if (nextTask.length > 0) {
        await this.scheduleNotificationsForTasks(nextTask);
        Logger.info('[TaskReminderIntegration] Scheduled notification for next recurring task', { 
          completedTaskId: completedTask.id, 
          nextTaskId: nextTask[0]?.id 
        });
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error scheduling notification for next recurring task', { 
        completedTaskId: completedTask.id, 
        error 
      });
    }
  }

  private async getActiveTasks(plantId: string): Promise<PlantTask[]> {
    return await database
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('plant_id', plantId),
        Q.where('status', 'pending')
      )
      .fetch();
  }

  /**
   * Public utility methods for external integration
   */

  /**
   * Get notification statistics
   */
  getNotificationStats() {
    return taskReminderEngine.getNotificationStats();
  }

  /**
   * Clear all cached notification data
   */
  clearNotificationCache(): void {
    taskReminderEngine.clearCache();
  }

  /**
   * Manually trigger overdue task processing
   */
  async triggerOverdueProcessing(): Promise<void> {
    await this.processOverdueTasks();
  }

  /**
   * Schedule notifications for specific tasks (external API)
   */
  async scheduleNotifications(tasks: PlantTask[]): Promise<void> {
    await this.scheduleNotificationsForTasks(tasks);
  }

  /**
   * Cancel notifications for specific tasks (external API)
   */
  async cancelNotifications(taskIds: string[]): Promise<void> {
    const cancelPromises = taskIds.map(taskId => 
      taskReminderEngine.cancelTaskNotifications(taskId)
    );
    await Promise.allSettled(cancelPromises);
  }
}

// Export singleton instance
export const taskReminderIntegration = TaskReminderIntegration.getInstance();