/**
 * Task Reminder Integration Service
 * 
 * Integrates TaskReminderEngine with existing task management services
 * and provides seamless notification management for the task system.
 * 
 * This service acts as a bridge between:
 * - TaskAutomationService (task creation and scheduling)
 * - TaskSchedulingAdapter (task lifecycle management)
 * - TaskReminderEngine (notification management)
 * - PlantTask model (data persistence)
 */

import { Q } from '@nozbe/watermelondb';

import { database } from '@/lib/models';
import { PlantTask } from '@/lib/models/PlantTask';
import { Plant } from '@/lib/models/Plant';
import { taskReminderEngine, TaskNotificationConfig } from './TaskReminderEngine';
import { TaskAutomationService } from './TaskAutomationService';
import { TaskSchedulingAdapter } from './TaskSchedulingAdapter';
import { Logger } from '@/lib/utils/production-utils';
import { TaskType } from '@/lib/types/taskTypes';
import { GrowthStage } from '@/lib/types/plant';

export class TaskReminderIntegration {
  private static instance: TaskReminderIntegration;

  public static getInstance(): TaskReminderIntegration {
    if (!TaskReminderIntegration.instance) {
      TaskReminderIntegration.instance = new TaskReminderIntegration();
    }
    return TaskReminderIntegration.instance;
  }

  /**
   * Initialize task reminder system for a plant
   * Called when a plant is created or when growth stage changes
   */
  async initializeTaskReminders(plant: Plant, growthStage?: GrowthStage): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Initializing task reminders for plant', { 
        plantId: plant.id, 
        plantName: plant.name,
        growthStage: growthStage || plant.growthStage 
      });

      // Generate tasks for the plant's current growth stage
      const tasks = await TaskAutomationService.scheduleForGrowthStage(
        plant, 
        (growthStage || plant.growthStage) as GrowthStage
      );

      if (tasks.length > 0) {
        // Schedule notifications for all generated tasks
        await this.scheduleNotificationsForTasks(tasks);
        
        Logger.info('[TaskReminderIntegration] Initialized reminders for plant', { 
          plantId: plant.id, 
          taskCount: tasks.length 
        });
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error initializing task reminders', { 
        plantId: plant.id, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle growth stage transition
   * Updates task schedules and notifications when plant growth stage changes
   */
  async handleGrowthStageTransition(
    plant: Plant, 
    oldStage: GrowthStage, 
    newStage: GrowthStage
  ): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling growth stage transition', { 
        plantId: plant.id, 
        oldStage, 
        newStage 
      });

      // Cancel notifications for old stage tasks that are no longer relevant
      await this.cancelNotificationsForGrowthStage(plant.id, oldStage);

      // Update existing tasks for new growth stage
      await TaskSchedulingAdapter.updateTasksForGrowthStageChange(plant, oldStage, newStage);

      // Generate new tasks for the new growth stage
      const newTasks = await TaskAutomationService.scheduleForGrowthStage(plant, newStage);

      // Schedule notifications for new tasks
      if (newTasks.length > 0) {
        await this.scheduleNotificationsForTasks(newTasks);
      }

      Logger.info('[TaskReminderIntegration] Completed growth stage transition', { 
        plantId: plant.id, 
        newTaskCount: newTasks.length 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling growth stage transition', { 
        plantId: plant.id, 
        oldStage, 
        newStage, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle task completion
   * Updates notifications and schedules next recurring task if applicable
   */
  async handleTaskCompletion(task: PlantTask): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task completion', { 
        taskId: task.id, 
        taskType: task.taskType 
      });

      // Cancel notifications for completed task
      await taskReminderEngine.cancelTaskNotifications(task.id);

      // If this is a recurring task, the PlantTask model will automatically
      // create the next occurrence. We need to schedule notifications for it.
      if (task.autoGenerated && (task.templateId || task.parentTaskId)) {
        await this.waitForAndScheduleNextRecurringTask(task);
      }

      Logger.info('[TaskReminderIntegration] Completed task completion handling', { 
        taskId: task.id 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task completion', { 
        taskId: task.id, 
        error 
      });
      // Don't throw here as task completion should still succeed
    }
  }

  /**
   * Handle task rescheduling
   * Updates notification timing when task due date changes
   */
  async handleTaskReschedule(task: PlantTask, newDueDate: Date): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task reschedule', { 
        taskId: task.id, 
        oldDueDate: task.dueDate, 
        newDueDate 
      });

      // Reschedule the notification
      await taskReminderEngine.rescheduleTaskNotification(task.id, newDueDate);

      Logger.info('[TaskReminderIntegration] Completed task reschedule', { taskId: task.id });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task reschedule', { 
        taskId: task.id, 
        error 
      });
      throw error;
    }
  }

  /**
   * Handle task deletion
   * Cancels all notifications for deleted task
   */
  async handleTaskDeletion(taskId: string): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling task deletion', { taskId });

      // Cancel all notifications for the task
      await taskReminderEngine.cancelTaskNotifications(taskId);

      Logger.info('[TaskReminderIntegration] Completed task deletion handling', { taskId });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling task deletion', { 
        taskId, 
        error 
      });
      // Don't throw here as task deletion should still succeed
    }
  }

  /**
   * Bulk operations for task management
   */
  async handleBulkTaskCompletion(taskIds: string[]): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling bulk task completion', { 
        taskCount: taskIds.length 
      });

      // Cancel notifications for all completed tasks
      const cancelPromises = taskIds.map(taskId => 
        taskReminderEngine.cancelTaskNotifications(taskId)
      );

      await Promise.allSettled(cancelPromises);

      // Handle recurring task scheduling for each completed task
      const recurringTaskPromises = taskIds.map(async (taskId) => {
        try {
          const task = await database.get<PlantTask>('plant_tasks').find(taskId);
          if (task.autoGenerated && (task.templateId || task.parentTaskId)) {
            await this.waitForAndScheduleNextRecurringTask(task);
          }
        } catch (taskError) {
          Logger.warn('[TaskReminderIntegration] Could not handle recurring task for completed task', { 
            taskId, 
            error: taskError 
          });
        }
      });

      await Promise.allSettled(recurringTaskPromises);

      Logger.info('[TaskReminderIntegration] Completed bulk task completion handling');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling bulk task completion', { error });
      throw error;
    }
  }

  async handleBulkTaskReschedule(taskIds: string[], newDueDate: Date): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling bulk task reschedule', { 
        taskCount: taskIds.length, 
        newDueDate 
      });

      // Reschedule notifications for all tasks
      const reschedulePromises = taskIds.map(taskId => 
        taskReminderEngine.rescheduleTaskNotification(taskId, newDueDate)
      );

      await Promise.allSettled(reschedulePromises);

      Logger.info('[TaskReminderIntegration] Completed bulk task reschedule handling');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling bulk task reschedule', { error });
      throw error;
    }
  }

  /**
   * Environmental condition updates
   * Adjusts task schedules and notifications based on environmental changes
   */
  async handleEnvironmentalUpdate(
    plantId: string, 
    conditions: {
      temperature?: number;
      humidity?: number;
      pH?: number;
    }
  ): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Handling environmental update', { 
        plantId, 
        conditions 
      });

      // Adjust task schedules based on environmental conditions
      await TaskAutomationService.adjustScheduleForConditions(plantId, conditions);

      // Get updated tasks and reschedule notifications
      const updatedTasks = await this.getActiveTasks(plantId);
      await this.scheduleNotificationsForTasks(updatedTasks);

      Logger.info('[TaskReminderIntegration] Completed environmental update handling', { 
        plantId, 
        updatedTaskCount: updatedTasks.length 
      });
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error handling environmental update', { 
        plantId, 
        error 
      });
      throw error;
    }
  }

  /**
   * Process overdue tasks across all plants
   * Should be called periodically (e.g., every 5 minutes)
   */
  async processOverdueTasks(): Promise<void> {
    try {
      Logger.info('[TaskReminderIntegration] Processing overdue tasks');

      await taskReminderEngine.processOverdueTasks();

      Logger.info('[TaskReminderIntegration] Completed overdue task processing');
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error processing overdue tasks', { error });
      throw error;
    }
  }

  /**
   * Private helper methods
   */

  private async scheduleNotificationsForTasks(tasks: PlantTask[]): Promise<void> {
    try {
      const configs: TaskNotificationConfig[] = [];

      for (const task of tasks) {
        try {
          const plant = await database.get<Plant>('plants').find(task.plantId);
          
          const config: TaskNotificationConfig = {
            taskId: task.id,
            plantId: task.plantId,
            plantName: plant.name,
            taskType: task.taskType as TaskType,
            taskTitle: task.title,
            dueDate: new Date(task.dueDate),
            priority: task.priority || 'medium',
            estimatedDuration: task.estimatedDuration,
            isRecurring: task.autoGenerated,
          };

          configs.push(config);
        } catch (plantError) {
          Logger.warn('[TaskReminderIntegration] Could not fetch plant for task notification', { 
            taskId: task.id, 
            error: plantError 
          });
        }
      }

      if (configs.length > 0) {
        await taskReminderEngine.scheduleTaskNotifications(configs);
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error scheduling notifications for tasks', { error });
      throw error;
    }
  }

  private async cancelNotificationsForGrowthStage(
    plantId: string, 
    growthStage: GrowthStage
  ): Promise<void> {
    try {

      // TODO: Add 'growth_stage' field to PlantTask model to enable filtering by growth stage here.
      // Tracking requirement: This is needed for precise notification cancellation when growth stage changes.
      // For now, we'll cancel all pending notifications and reschedule.
      const tasks = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', plantId),
          Q.where('status', 'pending')
        )
        .fetch();

      const cancelPromises = tasks.map(task => 
        taskReminderEngine.cancelTaskNotifications(task.id)
      );

      await Promise.allSettled(cancelPromises);
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error cancelling notifications for growth stage', { 
        plantId, 
        growthStage, 
        error 
      });
    }
  }

  private async scheduleNotificationsForNextRecurringTask(completedTask: PlantTask): Promise<void> {
    try {
      // Find the next task in the recurring series
      const nextTask = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', completedTask.plantId),
          Q.where('task_type', completedTask.taskType),
          Q.where('status', 'pending'),
          Q.where('parent_task_id', completedTask.parentTaskId || completedTask.id),
          Q.where('sequence_number', Q.gt(completedTask.sequenceNumber || 0)),
          Q.sortBy('sequence_number', Q.asc),
          Q.take(1)
        )
        .fetch();

      if (nextTask.length > 0) {
        await this.scheduleNotificationsForTasks(nextTask);
        Logger.info('[TaskReminderIntegration] Scheduled notification for next recurring task', { 
          completedTaskId: completedTask.id, 
          nextTaskId: nextTask[0]?.id 
        });
      }
    } catch (error) {
      Logger.error('[TaskReminderIntegration] Error scheduling notification for next recurring task', { 
        completedTaskId: completedTask.id, 
        error 
      });
    }
  }

  /**
   * Reliably waits for the next recurring task to be created and schedules notifications
   * Uses observables and polling with exponential backoff to handle race conditions
   */
  private async waitForAndScheduleNextRecurringTask(completedTask: PlantTask): Promise<void> {
    // Try observable approach first for maximum reliability
    try {
      const nextTask = await this.waitForNextTaskWithObservable(completedTask);
      if (nextTask) {
        await this.scheduleNotificationsForTasks([nextTask]);
        Logger.info('[TaskReminderIntegration] Successfully scheduled notification for next recurring task via observable', { 
          completedTaskId: completedTask.id, 
          nextTaskId: nextTask.id 
        });
        return;
      }
    } catch (observableError) {
      Logger.warn('[TaskReminderIntegration] Observable approach failed, falling back to polling', { 
        completedTaskId: completedTask.id, 
        error: observableError 
      });
    }

    // Fallback to polling approach
    const maxAttempts = 5;
    const baseDelay = 200; // Start with 200ms
    const maxDelay = 5000; // Maximum 5 seconds
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        // Try to find the next task
        const nextTask = await database
          .get<PlantTask>('plant_tasks')
          .query(
            Q.where('plant_id', completedTask.plantId),
            Q.where('task_type', completedTask.taskType),
            Q.where('status', 'pending'),
            Q.where('parent_task_id', completedTask.parentTaskId || completedTask.id),
            Q.where('sequence_number', Q.gt(completedTask.sequenceNumber || 0)),
            Q.sortBy('sequence_number', Q.asc),
            Q.take(1)
          )
          .fetch();

        if (nextTask.length > 0) {
          // Found the next task, schedule notifications
          await this.scheduleNotificationsForTasks(nextTask);
          Logger.info('[TaskReminderIntegration] Successfully scheduled notification for next recurring task via polling', { 
            completedTaskId: completedTask.id, 
            nextTaskId: nextTask[0]?.id,
            attempt 
          });
          return; // Success, exit early
        }

        // If we haven't found the task yet, wait before retrying
        if (attempt < maxAttempts) {
          const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
          Logger.debug('[TaskReminderIntegration] Next recurring task not found, retrying', { 
            completedTaskId: completedTask.id, 
            attempt, 
            nextDelay: delay 
          });
          
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error) {
        Logger.warn('[TaskReminderIntegration] Error searching for next recurring task', { 
          completedTaskId: completedTask.id, 
          attempt, 
          error 
        });
        
        // If this is the last attempt or a critical error, don't continue
        if (attempt === maxAttempts) {
          Logger.error('[TaskReminderIntegration] Failed to schedule notification for next recurring task after all attempts', { 
            completedTaskId: completedTask.id, 
            maxAttempts, 
            error 
          });
          return;
        }
        
        // Wait before retrying on error
        const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // If we get here, we've exhausted all attempts
    Logger.warn('[TaskReminderIntegration] No next recurring task found after all attempts', { 
      completedTaskId: completedTask.id, 
      maxAttempts 
    });
  }

  /**
   * Uses WatermelonDB observables to wait for the next recurring task to be created
   * More reliable than polling as it reacts immediately to database changes
   */
  private async waitForNextTaskWithObservable(completedTask: PlantTask): Promise<PlantTask | null> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        subscription.unsubscribe();
        resolve(null); // Timeout without finding task
      }, 10000); // 10 second timeout

      // Observe tasks for this plant that match our criteria
      const subscription = database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', completedTask.plantId),
          Q.where('task_type', completedTask.taskType),
          Q.where('status', 'pending'),
          Q.where('parent_task_id', completedTask.parentTaskId || completedTask.id),
          Q.where('sequence_number', Q.gt(completedTask.sequenceNumber || 0))
        )
        .observe()
        .subscribe({
          next: (tasks) => {
            if (tasks.length > 0) {
              // Sort to get the next task in sequence
              const sortedTasks = tasks.sort((a, b) => 
                (a.sequenceNumber || 0) - (b.sequenceNumber || 0)
              );
              
              const nextTask = sortedTasks[0];
              if (nextTask) {
                clearTimeout(timeout);
                subscription.unsubscribe();
                resolve(nextTask);
              }
            }
          },
          error: (error) => {
            clearTimeout(timeout);
            subscription.unsubscribe();
            reject(error);
          }
        });
    });
  }

  private async getActiveTasks(plantId: string): Promise<PlantTask[]> {
    return await database
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('plant_id', plantId),
        Q.where('status', 'pending')
      )
      .fetch();
  }

  /**
   * Public utility methods for external integration
   */

  /**
   * Get notification statistics
   */
  getNotificationStats() {
    return taskReminderEngine.getNotificationStats();
  }

  /**
   * Clear all cached notification data
   */
  clearNotificationCache(): void {
    taskReminderEngine.clearCache();
  }

  /**
   * Manually trigger overdue task processing
   */
  async triggerOverdueProcessing(): Promise<void> {
    await this.processOverdueTasks();
  }

  /**
   * Schedule notifications for specific tasks (external API)
   */
  async scheduleNotifications(tasks: PlantTask[]): Promise<void> {
    await this.scheduleNotificationsForTasks(tasks);
  }

  /**
   * Cancel notifications for specific tasks (external API)
   */
  async cancelNotifications(taskIds: string[]): Promise<void> {
    const cancelPromises = taskIds.map(taskId => 
      taskReminderEngine.cancelTaskNotifications(taskId)
    );
    await Promise.allSettled(cancelPromises);
  }
}

// Export singleton instance
export const taskReminderIntegration = TaskReminderIntegration.getInstance();