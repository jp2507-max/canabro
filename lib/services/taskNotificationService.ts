import { Q } from '@nozbe/watermelondb';
import { database } from '@/lib/models';
import { PlantTask } from '@/lib/models/PlantTask';
import { Plant } from '@/lib/models/Plant';
import { Logger } from '@/lib/utils/production-utils';
import type { TaskType } from '@/lib/types/taskTypes';
import { generateUuid } from '@/lib/utils/uuid';
import i18n from '@/lib/config/i18n';

export interface CreateTaskWithNotificationOptions {
  plantId: string;
  taskType: TaskType;
  title: string;
  description?: string;
  dueDate: Date;
  priority?: 'low' | 'medium' | 'high' | 'critical';
  estimatedDuration?: number; // minutes
  repeatInterval?: number; // days
}

export interface TaskNotificationStats {
  total: number;
  overdue: number;
  dueToday: number;
  dueSoon: number; // within 2 days
  completed: number;
  byPriority: {
    low: number;
    medium: number;
    high: number;
    critical: number;
  };
}

export interface TaskViewData {
  id: string;
  plantId: string;
  plantName: string;
  taskType: TaskType;
  title: string;
  scheduledDate: Date;
  priority: 'low' | 'medium' | 'high' | 'critical';
  isCompleted: boolean;
  isOverdue: boolean;
  estimatedDuration?: number; // minutes
  plantImage?: string;
  description?: string;
}

export class TaskNotificationService {
  private static instance: TaskNotificationService;
  
  public static getInstance(): TaskNotificationService {
    if (!TaskNotificationService.instance) {
      TaskNotificationService.instance = new TaskNotificationService();
    }
    return TaskNotificationService.instance;
  }

  /**
   * Create a new task with notification scheduling
   * Adapts the CareReminder pattern for task-focused workflow
   */
  async createTaskWithNotification(options: CreateTaskWithNotificationOptions): Promise<PlantTask> {
    return await database.write(async () => {
      return await database.get<PlantTask>('plant_tasks').create((task) => {
        task.taskId = generateUuid();
        task.plantId = options.plantId;
        task.title = options.title;
        task.description = options.description;
        task.taskType = options.taskType;
        task.dueDate = options.dueDate.toISOString();
        task.status = 'pending';
        task.priority = options.priority || 'medium';
        task.estimatedDuration = options.estimatedDuration;
        task.autoGenerated = false;
        
        // Set user ID from plant if available
        // This will be populated by the database relation
        task.userId = ''; // Will be set by the plant relation
      });
    });
  }

  /**
   * Get all active tasks for a plant (adapts getActiveRemindersForPlant)
   */
  async getActiveTasksForPlant(plantId: string): Promise<PlantTask[]> {
    const tasks = await database.collections
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('plant_id', plantId),
        Q.where('status', Q.notEq('completed')),
        Q.sortBy('due_date', Q.asc)
      )
      .fetch();

    return tasks;
  }

  /**
   * Get all active tasks across all plants (adapts getAllActiveReminders)
   */
  async getAllActiveTasks(): Promise<PlantTask[]> {
    const tasks = await database.collections
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('status', Q.notEq('completed')),
        Q.sortBy('due_date', Q.asc)
      )
      .fetch();

    return tasks;
  }

  /**
   * Get tasks for a specific date range (optimized for 5-day view)
   */
  async getTasksForDateRange(startDate: Date, endDate: Date): Promise<TaskViewData[]> {
    const tasks = await database.collections
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('due_date', Q.between(startDate.getTime(), endDate.getTime())),
        Q.sortBy('due_date', Q.asc)
      )
      .fetch();

    // Transform to TaskViewData with plant information
    const taskViewData: TaskViewData[] = [];
    
    for (const task of tasks) {
      try {
        const plant = await database.get<Plant>('plants').find(task.plantId);
        
        taskViewData.push({
          id: task.id,
          plantId: task.plantId,
          plantName: plant.name,
          taskType: task.taskType,
          title: task.title,
          scheduledDate: new Date(task.dueDate),
          priority: task.priorityLevel,
          isCompleted: task.isCompleted,
          isOverdue: task.isOverdue,
          estimatedDuration: task.estimatedDuration,
          plantImage: plant.imageUrl,
          description: task.description,
        });
      } catch (error) {
        Logger.error('Failed to fetch plant for task', { taskId: task.id, error });
        // Include task without plant data
        taskViewData.push({
          id: task.id,
          plantId: task.plantId,
          plantName: 'Unknown Plant',
          taskType: task.taskType,
          title: task.title,
          scheduledDate: new Date(task.dueDate),
          priority: task.priorityLevel,
          isCompleted: task.isCompleted,
          isOverdue: task.isOverdue,
          estimatedDuration: task.estimatedDuration,
          description: task.description,
        });
      }
    }

    return taskViewData;
  }

  /**
   * Get tasks that need attention (overdue or due today)
   * Adapts getRemindersNeedingAttention for task workflow
   */
  async getTasksNeedingAttention(): Promise<PlantTask[]> {
    const tasks = await this.getAllActiveTasks();
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    return tasks.filter((task) => {
      const dueDate = new Date(task.dueDate);
      return dueDate < tomorrow; // Overdue or due today
    });
  }

  /**
   * Get task statistics (adapts getReminderStats)
   */
  async getTaskStats(): Promise<TaskNotificationStats> {
    const allTasks = await database.collections
      .get<PlantTask>('plant_tasks')
      .query()
      .fetch();

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const twoDaysFromNow = new Date(today);
    twoDaysFromNow.setDate(twoDaysFromNow.getDate() + 2);

    const stats: TaskNotificationStats = {
      total: 0,
      overdue: 0,
      dueToday: 0,
      dueSoon: 0,
      completed: 0,
      byPriority: {
        low: 0,
        medium: 0,
        high: 0,
        critical: 0,
      },
    };

    allTasks.forEach((task) => {
      if (task.isCompleted) {
        stats.completed++;
        return;
      }

      stats.total++;
      const dueDate = new Date(task.dueDate);
      const priority = task.priorityLevel;

      // Count by priority
      stats.byPriority[priority]++;

      // Count by due date
      if (dueDate < today) {
        stats.overdue++;
      } else if (
        dueDate >= today &&
        dueDate < new Date(today.getTime() + 24 * 60 * 60 * 1000)
      ) {
        stats.dueToday++;
      } else if (dueDate < twoDaysFromNow) {
        stats.dueSoon++;
      }
    });

    return stats;
  }

  /**
   * Mark task as completed (adapts markReminderCompleted)
   */
  async markTaskCompleted(
    taskId: string,
    completionData?: {
      completedAt?: string | Date;
      notes?: string;
      photos?: string[];
      [key: string]: unknown;
    }
  ): Promise<void> {
    try {
      const task = await database.collections
        .get<PlantTask>('plant_tasks')
        .find(taskId);

      // Normalize to model's expected shape: Date for completedAt
      let normalized: Record<string, unknown> | undefined;
      if (completionData) {
        const completedAt =
          typeof completionData.completedAt === 'string'
            ? new Date(completionData.completedAt)
            : completionData.completedAt;

        normalized = {
          ...completionData,
          completedAt,
        };
      }

      await task.markAsCompleted(normalized as unknown as Partial<unknown>);
    } catch (error) {
      Logger.error('Failed to mark task as completed', { taskId, error });
    }
  }

  /**
   * Snooze task by specified hours (adapts snoozeReminder)
   */
  async snoozeTask(taskId: string, hours: number = 24): Promise<void> {
    try {
      const task = await database.collections
        .get<PlantTask>('plant_tasks')
        .find(taskId);
      await task.snooze(hours);
    } catch (error) {
      Logger.error('Failed to snooze task', { taskId, hours, error });
    }
  }

  /**
   * Reschedule task to a specific date (adapts rescheduleReminder)
   */
  async rescheduleTask(taskId: string, newDate: Date): Promise<void> {
    try {
      const task = await database.collections
        .get<PlantTask>('plant_tasks')
        .find(taskId);
      await task.reschedule(newDate.toISOString());
    } catch (error) {
      Logger.error('Failed to reschedule task', { taskId, newDate, error });
    }
  }

  /**
   * Delete task (soft delete)
   */
  async deleteTask(taskId: string): Promise<void> {
    try {
      const task = await database.collections
        .get<PlantTask>('plant_tasks')
        .find(taskId);
      
      await database.write(async () => {
        await task.update((t) => {
          t.status = 'deleted';
        });
      });
    } catch (error) {
      Logger.error('Failed to delete task', { taskId, error });
    }
  }

  /**
   * Create default tasks for a new plant (adapts createDefaultRemindersForPlant)
   */
  async createDefaultTasksForPlant(plant: Plant): Promise<PlantTask[]> {
    const now = new Date();
    const tasks: PlantTask[] = [];

    try {
      await database.write(async () => {
        // Default watering task (every 3 days)
        const wateringDate = new Date(now);
        wateringDate.setDate(wateringDate.getDate() + (plant.nextWateringDays || 3));
        
        const wateringTask = await database.get<PlantTask>('plant_tasks').create((task) => {
          task.taskId = generateUuid();
          task.plantId = plant.id;
          task.title = `Water ${plant.name}`;
          task.description = 'Time to water your plant';
          task.taskType = 'watering';
          task.dueDate = wateringDate.toISOString();
          task.status = 'pending';
          task.priority = 'medium';
          task.estimatedDuration = 10;
          task.autoGenerated = true;
          task.userId = plant.userId;
        });
        tasks.push(wateringTask);

        // Default feeding task (every 7 days)
        const feedingDate = new Date(now);
        feedingDate.setDate(feedingDate.getDate() + (plant.nextNutrientDays || 7));
        
        const feedingTask = await database.get<PlantTask>('plant_tasks').create((task) => {
          task.taskId = generateUuid();
          task.plantId = plant.id;
          task.title = `Feed ${plant.name}`;
          task.description = 'Time to feed your plant with nutrients';
          task.taskType = 'feeding';
          task.dueDate = feedingDate.toISOString();
          task.status = 'pending';
          task.priority = 'medium';
          task.estimatedDuration = 15;
          task.autoGenerated = true;
          task.userId = plant.userId;
        });
        tasks.push(feedingTask);

        // Weekly inspection task
        const inspectionDate = new Date(now);
        inspectionDate.setDate(inspectionDate.getDate() + 7);
        
        const inspectionTask = await database.get<PlantTask>('plant_tasks').create((task) => {
          task.taskId = generateUuid();
          task.plantId = plant.id;
          task.title = `Check ${plant.name}`;
          task.description = 'Time for a general health inspection';
          task.taskType = 'inspection';
          task.dueDate = inspectionDate.toISOString();
          task.status = 'pending';
          task.priority = 'low';
          task.estimatedDuration = 5;
          task.autoGenerated = true;
          task.userId = plant.userId;
        });
        tasks.push(inspectionTask);
      });
    } catch (error) {
      Logger.error('Failed to create default tasks for plant', { plantId: plant.id, error });
    }

    return tasks;
  }

  /**
   * Batch operations (adapts from CareReminderService)
   */
  async batchMarkCompleted(taskIds: string[]): Promise<void> {
    await database.write(async () => {
      await Promise.all(
        taskIds.map(async (id) => {
          try {
            const task = await database.collections
              .get<PlantTask>('plant_tasks')
              .find(id);
            await task.markAsCompleted();
            return { id, success: true };
          } catch (error) {
            console.warn(
              i18n.t('taskNotifications.errorBatchMarkingDone'),
              error
            );
            return { id, success: false, error };
          }
        })
      );
    });
  }

  async batchSnooze(taskIds: string[], hours: number = 24): Promise<void> {
    await database.write(async () => {
      const promises = taskIds.map(async (id) => {
        const task = await database.collections
          .get<PlantTask>('plant_tasks')
          .find(id);
        return task.snooze(hours);
      });
      
      await Promise.all(promises);
    });
  }

  async batchDelete(taskIds: string[]): Promise<void> {
    await database.write(async () => {
      const promises = taskIds.map(async (id) => {
        const task = await database.collections
          .get<PlantTask>('plant_tasks')
          .find(id);
        return task.update((t) => {
          t.status = 'deleted';
        });
      });
      
      await Promise.all(promises);
    });
  }

  /**
   * Clean up old completed tasks (older than 30 days)
   */
  async cleanupOldTasks(): Promise<number> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const oldTasks = await database.collections
      .get<PlantTask>('plant_tasks')
      .query(
        Q.where('status', 'completed'),
        Q.where('updated_at', Q.lt(thirtyDaysAgo.getTime()))
      )
      .fetch();

    await database.write(async () => {
      const promises = oldTasks.map((task) => 
        task.update((t) => {
          t.status = 'deleted';
        })
      );
      await Promise.all(promises);
    });

    return oldTasks.length;
  }

  /**
   * Get tasks for 5-day view (optimized for task management interface)
   */
  async getTasksForWeekView(startDate: Date): Promise<TaskViewData[]> {
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 4); // 5-day view
    endDate.setHours(23, 59, 59, 999); // End of day

    return this.getTasksForDateRange(startDate, endDate);
  }

  /**
   * Generate task notification content (task-focused messaging)
   */
  generateTaskNotificationContent(task: PlantTask, plant: Plant): {
    title: string;
    body: string;
    data: Record<string, unknown>;
  } {
    const priorityEmoji = {
      low: '🟢',
      medium: '🟡',
      high: '🟠',
      critical: '🔴',
    };

    const taskTypeEmoji = {
      watering: '💧',
      feeding: '🌱',
      inspection: '👀',
      pruning: '✂️',
      training: '🏋️',
      harvest: '🌾',
      custom: '📝',
    };

    const emoji = taskTypeEmoji[task.taskType as keyof typeof taskTypeEmoji] || '📝';
    const priority = priorityEmoji[task.priorityLevel];

    return {
      title: `${emoji} ${plant.name} - ${task.title}`,
      body: `${task.description || ''} ${priority} Priority${task.estimatedDuration ? ` • ~${task.estimatedDuration}min` : ''}`,
      data: {
        taskId: task.id,
        plantId: plant.id,
        taskType: task.taskType,
        priority: task.priorityLevel,
        navigateTo: 'calendar',
        selectedDate: task.dueDate,
      },
    };
  }

  /**
   * Reschedule multiple tasks to a new date
   */
  async batchReschedule(taskIds: string[], newDate: Date): Promise<void> {
    try {
      Logger.info('[TaskNotificationService] Batch rescheduling tasks', { 
        taskCount: taskIds.length, 
        newDate: newDate.toISOString() 
      });

      await database.write(async () => {
        const tasks = await database
          .get<PlantTask>('plant_tasks')
          .query(Q.where('id', Q.oneOf(taskIds)));

        const updates = tasks.map(task => 
          task.prepareUpdate(record => {
            record.dueDate = newDate.toISOString();
          })
        );

        await database.batch(...updates);
      });

      Logger.info('[TaskNotificationService] Successfully rescheduled tasks');
    } catch (error) {
      Logger.error('[TaskNotificationService] Failed to batch reschedule tasks', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        taskIds,
        newDate: newDate.toISOString()
      });
      throw error;
    }
  }
}

// Export singleton instance
export const taskNotificationService = TaskNotificationService.getInstance();
