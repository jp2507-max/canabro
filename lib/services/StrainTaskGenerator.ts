import { database } from '../models';
import { Plant } from '../models/Plant';
import { PlantTask } from '../models/PlantTask';
import { addDays } from '../utils/date';
import { TaskType } from '../types/taskTypes';
import { getStrainById } from '../data/strains';

export interface GenerateStrainTasksInput {
  templateVersion?: number;
  enableFlush?: boolean;
  enableDarkPeriod?: boolean;
}

type Difficulty = 'easy' | 'medium' | 'hard';

function difficultyMultiplier(d: Difficulty | undefined): number {
  switch (d) {
    case 'easy':
      return 0.8;
    case 'hard':
      return 1.2;
    default:
      return 1.0;
  }
}

function safeDate(iso?: string | Date | null): Date | null {
  if (!iso) return null;
  const d = iso instanceof Date ? iso : new Date(iso);
  return isNaN(d.getTime()) ? null : d;
}

export class StrainTaskGenerator {
  static async generateAnchoredTasks(
    plant: Plant,
    opts: GenerateStrainTasksInput = {}
  ): Promise<PlantTask[]> {
    const tasks: PlantTask[] = [];

    const harvestStart = safeDate(plant.predictedHarvestStart as Date | undefined);
    const harvestEnd = safeDate(plant.predictedHarvestEnd as Date | undefined);

    // Derive difficulty from strain metadata when available
    let diff: Difficulty | undefined;
    if (plant.strainId) {
      const strain = getStrainById(plant.strainId);
      const raw = strain?.growDifficulty?.toLowerCase();
      if (raw === 'easy') diff = 'easy';
      else if (raw === 'hard') diff = 'hard';
      else if (raw === 'moderate' || raw === 'medium') diff = 'medium';
    }

    if (!harvestStart) {
      return tasks;
    }

    // Load existing auto, unlocked tasks to avoid duplicates (idempotency)
    const existing = await database.get<PlantTask>('plant_tasks').query().fetch();
    const existingIndex = new Set(
      existing
        .filter((t) => t.plantId === plant.id && t.source === 'auto')
        .map((t) => `${t.taskType}|${new Date(t.dueDate).toDateString()}`)
    );

    const anchors: Array<{
      offsetDays: number;
      title: string;
      type: TaskType;
      optional?: boolean;
    }> = [
      { offsetDays: -10, title: 'Flush (optional)', type: 'flushing', optional: true },
      { offsetDays: -7, title: 'Pre-harvest checks', type: 'inspection' },
      { offsetDays: -2, title: 'Dark period (optional)', type: 'inspection', optional: true },
    ];

    const enableFlush = opts.enableFlush ?? true;
    const enableDark = opts.enableDarkPeriod ?? false;

    const multiplier = difficultyMultiplier(diff);

    await database.write(async () => {
      for (const a of anchors) {
        if (a.optional && a.title.includes('Flush') && !enableFlush) continue;
        if (a.optional && a.title.includes('Dark') && !enableDark) continue;

        const due = addDays(harvestStart, Math.round(a.offsetDays * multiplier));
        const dedupeKey = `${a.type}|${due.toDateString()}`;
        if (existingIndex.has(dedupeKey)) {
          continue;
        }

        const task = await database.get<PlantTask>('plant_tasks').create((t: PlantTask) => {
          t.taskId = `${plant.id}-${a.type}-${due.toISOString()}`;
          t.plantId = plant.id;
          t.title = a.title;
          t.description = undefined;
          t.taskType = a.type;
          t.dueDate = due.toISOString();
          t.status = 'pending';
          t.userId = plant.userId;
          t.priority = a.type === 'inspection' ? 'high' : 'medium';
          t.autoGenerated = true;
          t.source = 'auto';
          t.locked = false;
          if (opts.templateVersion) t.templateVersion = opts.templateVersion;
          t.strainMetadata = {
            difficulty: diff,
            harvestWindow: {
              start: harvestStart?.toISOString(),
              end: harvestEnd?.toISOString(),
            },
            strainId: plant.strainId || undefined,
          };
        });
        tasks.push(task);
      }
    });

    return tasks;
  }

  /**
   * Update only auto-generated, unlocked tasks when regenerating for the plant.
   */
  static async regenerateForPlant(
    plant: Plant,
    opts: GenerateStrainTasksInput = {}
  ): Promise<{ updated: number; created: number }> {
    const collection = database.get<PlantTask>('plant_tasks');
    const existing = await collection.query().fetch();
    const candidate = existing.filter(
      (t) => t.plantId === plant.id && t.source === 'auto' && !t.locked
    );

    // Simple strategy: delete candidates and recreate for now
    await database.write(async () => {
      for (const t of candidate) {
        await t.markAsDeleted?.();
      }
    });

    const createdTasks = await this.generateAnchoredTasks(plant, opts);
    return { updated: 0, created: createdTasks.length };
  }
}

export default StrainTaskGenerator;


