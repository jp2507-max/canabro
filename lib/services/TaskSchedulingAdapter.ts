/**
 * Task Scheduling Adapter
 * 
 * Adapts existing CareReminder system for PlantTask automation
 * and integrates with the 5-day task management workflow.
 * 
 * This service bridges the gap between the existing CareReminder model
 * and the new PlantTask model for the advanced calendar system.
 */

import { Q } from '@nozbe/watermelondb';
import { addDays, format } from '../utils/date';
import { log } from '../utils/logger';

import { Plant } from '../models/Plant';
import { PlantTask } from '../models/PlantTask';
import { CareReminder } from '../models/CareReminder';
import { TaskAutomationService } from './TaskAutomationService';
import { GrowthStage } from '../types/plant';
import { TaskType } from '../types/taskTypes';
import database from '../database/database';

export class TaskSchedulingAdapter {
  /**
   * ✅ REUSE: Migrate existing CareReminders to PlantTasks
   * 
   * Converts existing CareReminder entries to PlantTask format
   * for compatibility with the new task management system.
   */
  static async migrateCareRemindersToTasks(plantId: string): Promise<PlantTask[]> {
    try {
      const tasks: PlantTask[] = [];

      // Get active care reminders for the plant
      const careReminders = await database
        .get<CareReminder>('care_reminders')
        .query(
          Q.where('plant_id', plantId),
          Q.where('is_completed', false),
          Q.where('is_deleted', false)
        )
        .fetch();

      log.info(`[TaskSchedulingAdapter] Migrating ${careReminders.length} care reminders to tasks for plant ${plantId}`);

      await database.write(async () => {
        for (const reminder of careReminders) {
          // Convert CareReminder type to TaskType
          const taskType = this.mapCareReminderTypeToTaskType(reminder.type);
          
          // Get the plant to extract userId
          const plant = await database.get<Plant>('plants').find(reminder.plantId);
          
          const task = await database.get<PlantTask>('plant_tasks').create((newTask: PlantTask) => {
            newTask.taskId = reminder.id; // Use reminder ID for consistency
            newTask.plantId = reminder.plantId;
            newTask.title = reminder.title;
            newTask.description = reminder.description || '';
            newTask.taskType = taskType;
            newTask.dueDate = reminder.scheduledFor.toISOString();
            newTask.status = reminder.isCompleted ? 'completed' : 'pending';
            newTask.userId = plant.userId;
            newTask.priority = reminder.priorityLevel === 'urgent' ? 'critical' : reminder.priorityLevel;
            newTask.autoGenerated = false; // Migrated from manual reminders
          });

          tasks.push(task);

          // Mark the original reminder as migrated (don't delete to preserve history)
          await reminder.update((r: any) => {
            r.description = `${r.description || ''} [MIGRATED TO TASK SYSTEM]`;
          });
        }
      });

      log.info(`[TaskSchedulingAdapter] Successfully migrated ${tasks.length} care reminders to tasks`);
      return tasks;
    } catch (error) {
      log.error(`[TaskSchedulingAdapter] Error migrating care reminders:`, error);
      return [];
    }
  }

  /**
   * ✅ REUSE: Sync PlantTasks back to CareReminders for compatibility
   * 
   * Creates CareReminder entries for PlantTasks to maintain compatibility
   * with existing notification and reminder systems.
   */
  static async syncTasksToCareReminders(plantId: string): Promise<void> {
    try {

      // Get pending tasks for the plant
      const pendingTasks = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', plantId),
          Q.where('status', 'pending')
        )
        .fetch();

      log.info(`[TaskSchedulingAdapter] Syncing ${pendingTasks.length} tasks to care reminders for plant ${plantId}`);

      await database.write(async () => {
        for (const task of pendingTasks) {
          // Check if a care reminder already exists for this task
          const existingReminder = await database
            .get<CareReminder>('care_reminders')
            .query(
              Q.where('plant_id', task.plantId),
              Q.where('title', task.title),
              Q.where('scheduled_for', task.dueDate)
            )
            .fetch();

          if (existingReminder.length === 0) {
            // Create new care reminder
            await database.get<CareReminder>('care_reminders').create((reminder: any) => {
              reminder.plantId = task.plantId;
              reminder.type = this.mapTaskTypeToCareReminderType(task.taskType);
              reminder.title = task.title;
              reminder.description = task.description || '';
              reminder.scheduledFor = new Date(task.dueDate);
              reminder.isCompleted = task.isCompleted;
              reminder.repeatInterval = this.getRepeatIntervalForTaskType(task.taskType);
            });
          }
        }
      });

      log.info(`[TaskSchedulingAdapter] Successfully synced tasks to care reminders`);
    } catch (error) {
      log.error(`[TaskSchedulingAdapter] Error syncing tasks to care reminders:`, error);
    }
  }

  /**
   * ✅ REUSE: Adapt recurring task logic for daily task management
   * 
   * Creates recurring task series based on existing CareReminder patterns
   * but optimized for 5-day workflow management.
   */
  static async createRecurringTaskSeries(
    plant: Plant,
    taskType: TaskType,
    startDate: Date,
    interval: number,
    count: number = 10
  ): Promise<PlantTask[]> {
    try {
      const tasks: PlantTask[] = [];

      log.info(`[TaskSchedulingAdapter] Creating recurring ${taskType} series for ${plant.name} (${count} tasks, ${interval} day interval)`);

      await database.write(async () => {
        for (let i = 0; i < count; i++) {
          const taskDate = addDays(startDate, i * interval);
          
          const task = await database.get<PlantTask>('plant_tasks').create((newTask: PlantTask) => {
            newTask.plantId = plant.id;
            newTask.title = `${this.getTaskDisplayName(taskType)} ${plant.name}`;
            newTask.description = this.getTaskDescription(taskType, plant.growthStage as GrowthStage);
            newTask.taskType = taskType;
            newTask.dueDate = taskDate.toISOString();
            newTask.status = 'pending';
            newTask.userId = plant.userId;
            newTask.priority = this.getTaskPriority(taskType, plant.growthStage as GrowthStage);
            newTask.estimatedDuration = this.getEstimatedDuration(taskType);
            newTask.autoGenerated = true;
            newTask.sequenceNumber = i + 1;
          });

          tasks.push(task);
        }
      });

      log.info(`[TaskSchedulingAdapter] Created ${tasks.length} recurring tasks for ${taskType}`);
      return tasks;
    } catch (error) {
      log.error(`[TaskSchedulingAdapter] Error creating recurring task series:`, error);
      return [];
    }
  }

  /**
   * ✅ REUSE: Growth stage integration for task prioritization
   * 
   * Updates task priorities and schedules when plant growth stage changes,
   * reusing existing growth stage detection logic.
   */
  static async updateTasksForGrowthStageChange(
    plant: Plant,
    oldStage: GrowthStage,
    newStage: GrowthStage
  ): Promise<void> {
    try {

      // Get pending tasks for the plant
      const pendingTasks = await database
        .get<PlantTask>('plant_tasks')
        .query(
          Q.where('plant_id', plant.id),
          Q.where('status', 'pending')
        )
        .fetch();

      log.info(`[TaskSchedulingAdapter] Updating ${pendingTasks.length} tasks for growth stage change: ${oldStage} → ${newStage}`);

      await database.write(async () => {
        for (const task of pendingTasks) {
          const newPriority = this.getTaskPriority(task.taskType, newStage);
          const newDescription = this.getTaskDescription(task.taskType, newStage);

          await task.update((t: PlantTask) => {
            t.priority = newPriority;
            t.description = newDescription;
          });
        }

        // Generate new stage-appropriate tasks
        const newTasks = await TaskAutomationService.scheduleForGrowthStage(plant, newStage);
        log.info(`[TaskSchedulingAdapter] Generated ${newTasks.length} new tasks for ${newStage} stage`);
      });

      log.info(`[TaskSchedulingAdapter] Successfully updated tasks for growth stage change`);
    } catch (error) {
      log.error(`[TaskSchedulingAdapter] Error updating tasks for growth stage change:`, error);
    }
  }

  /**
   * ✅ REUSE: Integrate with existing notification system
   * 
   * Ensures PlantTasks are properly integrated with the existing
   * notification scheduling system from NotificationService.
   */
  static async scheduleTaskNotifications(tasks: PlantTask[]): Promise<void> {
    try {
      // Import notification service dynamically to avoid circular dependencies
      const { scheduleTaskReminder } = await import('./NotificationService');

      for (const task of tasks) {
        const plant = await database.get<Plant>('plants').find(task.plantId);
        
        await scheduleTaskReminder({
          taskId: task.id,
          plantId: task.plantId,
          plantName: plant.name,
          taskType: this.mapTaskTypeToNotificationType(task.taskType),
          taskTitle: task.title,
          dueDate: new Date(task.dueDate),
        });
      }

      log.info(`[TaskSchedulingAdapter] Scheduled notifications for ${tasks.length} tasks`);
    } catch (error) {
      log.error(`[TaskSchedulingAdapter] Error scheduling task notifications:`, error);
    }
  }

  /**
   * Private helper methods for type mapping and configuration
   */

  private static mapCareReminderTypeToTaskType(reminderType: string): TaskType {
    const typeMap: Record<string, TaskType> = {
      watering: 'watering',
      nutrients: 'feeding',
      feeding: 'feeding',
      inspection: 'inspection',
      custom: 'inspection', // Default custom reminders to inspection
    };

    return typeMap[reminderType] || 'inspection';
  }

  private static mapTaskTypeToCareReminderType(taskType: TaskType): string {
    const typeMap: Record<TaskType, string> = {
      watering: 'watering',
      feeding: 'nutrients',
      inspection: 'inspection',
      pruning: 'custom',
      training: 'custom',
      defoliation: 'custom',
      flushing: 'custom',
      harvest: 'custom',
      transplant: 'custom',
    };

    return typeMap[taskType] || 'custom';
  }

  private static mapTaskTypeToNotificationType(taskType: TaskType): 'water' | 'feed' | 'prune' | 'transplant' | 'harvest' | 'other' {
    const typeMap: Record<TaskType, 'water' | 'feed' | 'prune' | 'transplant' | 'harvest' | 'other'> = {
      watering: 'water',
      feeding: 'feed',
      pruning: 'prune',
      transplant: 'transplant',
      harvest: 'harvest',
      inspection: 'other',
      training: 'other',
      defoliation: 'other',
      flushing: 'other',
    };

    return typeMap[taskType] || 'other';
  }

  private static getRepeatIntervalForTaskType(taskType: TaskType): number {
    const intervals: Record<TaskType, number> = {
      watering: 3,
      feeding: 7,
      inspection: 2,
      pruning: 14,
      training: 7,
      defoliation: 21,
      flushing: 14,
      harvest: 70,
      transplant: 30,
    };

    return intervals[taskType] || 7;
  }

  private static getTaskDisplayName(taskType: TaskType): string {
    const names: Record<TaskType, string> = {
      watering: 'Water',
      feeding: 'Feed',
      inspection: 'Inspect',
      pruning: 'Prune',
      training: 'Train',
      defoliation: 'Defoliate',
      flushing: 'Flush',
      harvest: 'Harvest',
      transplant: 'Transplant',
    };

    return names[taskType] || 'Care for';
  }

  private static getTaskDescription(taskType: TaskType, growthStage: GrowthStage): string {
    // Reuse description generation from TaskAutomationService
    const descriptions: Record<TaskType, string> = {
      watering: `Water plant according to ${growthStage} stage requirements`,
      feeding: `Feed plant with nutrients appropriate for ${growthStage} stage`,
      inspection: `Inspect plant health and progress in ${growthStage} stage`,
      pruning: `Prune plant as needed for ${growthStage} stage`,
      training: `Train plant growth for optimal development in ${growthStage} stage`,
      defoliation: `Remove excess foliage appropriate for ${growthStage} stage`,
      flushing: `Flush nutrients from growing medium in ${growthStage} stage`,
      harvest: `Harvest plant when ready in ${growthStage} stage`,
      transplant: `Transplant plant to appropriate container for ${growthStage} stage`,
    };

    return descriptions[taskType] || `Perform ${taskType} task for plant in ${growthStage} stage`;
  }

  private static getTaskPriority(taskType: TaskType, growthStage: GrowthStage): 'low' | 'medium' | 'high' | 'critical' {
    // Priority matrix based on task type and growth stage
    const priorityMatrix: Record<TaskType, Record<GrowthStage, 'low' | 'medium' | 'high' | 'critical'>> = {
      watering: {
        [GrowthStage.GERMINATION]: 'high',
        [GrowthStage.SEEDLING]: 'high',
        [GrowthStage.VEGETATIVE]: 'high',
        [GrowthStage.PRE_FLOWER]: 'high',
        [GrowthStage.FLOWERING]: 'high',
        [GrowthStage.LATE_FLOWERING]: 'medium',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      feeding: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'medium',
        [GrowthStage.VEGETATIVE]: 'high',
        [GrowthStage.PRE_FLOWER]: 'high',
        [GrowthStage.FLOWERING]: 'high',
        [GrowthStage.LATE_FLOWERING]: 'low',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      inspection: {
        [GrowthStage.GERMINATION]: 'high',
        [GrowthStage.SEEDLING]: 'high',
        [GrowthStage.VEGETATIVE]: 'medium',
        [GrowthStage.PRE_FLOWER]: 'high',
        [GrowthStage.FLOWERING]: 'high',
        [GrowthStage.LATE_FLOWERING]: 'critical',
        [GrowthStage.HARVEST]: 'high',
        [GrowthStage.CURING]: 'medium',
      },
      // Add other task types with default medium priority
      pruning: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'low',
        [GrowthStage.VEGETATIVE]: 'high',
        [GrowthStage.PRE_FLOWER]: 'medium',
        [GrowthStage.FLOWERING]: 'low',
        [GrowthStage.LATE_FLOWERING]: 'low',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      training: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'low',
        [GrowthStage.VEGETATIVE]: 'high',
        [GrowthStage.PRE_FLOWER]: 'medium',
        [GrowthStage.FLOWERING]: 'low',
        [GrowthStage.LATE_FLOWERING]: 'low',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      defoliation: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'low',
        [GrowthStage.VEGETATIVE]: 'medium',
        [GrowthStage.PRE_FLOWER]: 'high',
        [GrowthStage.FLOWERING]: 'medium',
        [GrowthStage.LATE_FLOWERING]: 'low',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      flushing: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'low',
        [GrowthStage.VEGETATIVE]: 'low',
        [GrowthStage.PRE_FLOWER]: 'low',
        [GrowthStage.FLOWERING]: 'low',
        [GrowthStage.LATE_FLOWERING]: 'high',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
      harvest: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'low',
        [GrowthStage.VEGETATIVE]: 'low',
        [GrowthStage.PRE_FLOWER]: 'low',
        [GrowthStage.FLOWERING]: 'low',
        [GrowthStage.LATE_FLOWERING]: 'medium',
        [GrowthStage.HARVEST]: 'critical',
        [GrowthStage.CURING]: 'low',
      },
      transplant: {
        [GrowthStage.GERMINATION]: 'low',
        [GrowthStage.SEEDLING]: 'medium',
        [GrowthStage.VEGETATIVE]: 'medium',
        [GrowthStage.PRE_FLOWER]: 'low',
        [GrowthStage.FLOWERING]: 'low',
        [GrowthStage.LATE_FLOWERING]: 'low',
        [GrowthStage.HARVEST]: 'low',
        [GrowthStage.CURING]: 'low',
      },
    };

    return priorityMatrix[taskType]?.[growthStage] || 'medium';
  }

  private static getEstimatedDuration(taskType: TaskType): number {
    const durations: Record<TaskType, number> = {
      watering: 15,
      feeding: 30,
      inspection: 10,
      pruning: 45,
      training: 30,
      defoliation: 60,
      flushing: 20,
      harvest: 240,
      transplant: 90,
    };

    return durations[taskType] || 30;
  }
}